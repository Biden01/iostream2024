{% extends 'lecture/lecture.html' %}

{% block title %}
    Сөздіктер
{% endblock %}

{% block header %}
    <h1>Сөздіктер</h1>
{% endblock %}

{% block task_nav_11 %}
    <p style="border-radius: 2px; background: rgba(10,9,9,0.22); padding: 5px; margin-bottom: 0">Есептер</p>
    <a href="{% url 'dict1' %}"><li>Сөздің пайда болу нөмірі</li></a>
    <a href="{% url 'dict2' %}"><li>Синонимдер сөздігі</li></a>
    <a href="{% url 'dict3' %}"><li>АҚШ сайлауы</li></a>
    <a href="{% url 'dict4' %}"><li>Ең жиі кездесетін сөз</li></a>
    <a href="{% url 'dict5' %}"><li>Қатынас құқығы</li></a>
    <a href="{% url 'dict6' %}"><li>Жиілікті талдау</li></a>
    <a href="{% url 'dict7' %}"><li>Елдер мен қалалар</li></a>
    <a href="{% url 'dict8' %}"><li>Ағылшынша-латын сөздігі</li></a>
    <a href="{% url 'dict9' %}"><li>Күйзелістерді тексеру</li></a>
    <a href="{% url 'dict10' %}"><li>Сату</li></a>
    <a href="{% url 'dict11' %}"><li>Тұқымдық: деңгейлерді санау</li></a>
    <a href="{% url 'dict12' %}"><li>Тұқым: ата-бабалар мен ұрпақ</li></a>
    <a href="{% url 'dict13' %}"><li>Тұқымдық: LCA</li></a>
{% endblock %}

{% block text_content1 %}
    <h1>1. Сөздіктер</h1>
    <p>Тұрақты тізімдер (массивтер) – нөмірленген элементтер жиыны, яғни тізімнің кез келген элементіне қол жеткізу үшін оның нөмірін көрсету керек. Тізімдегі элементтің нөмірі элементтің өзін бірегей түрде анықтайды. Бірақ деректерді сандық сандар арқылы анықтау әрқашан қолайлы бола бермейді. Мысалы, пойыз бағыттары сандық-алфавиттік кодпен (сан және бір әріп) анықталады, ал әуе рейстері де сандық-алфавиттік кодпен анықталады, яғни пойыз немесе ұшақ рейстері туралы ақпаратты сақтау үшін ол идентификатор ретінде санды емес, мәтіндік жолды пайдалану ыңғайлы болуы керек.</p>
    <p>Оның элементтерін сандық көрсеткішпен емес, ерікті түрде анықтауға мүмкіндік беретін деректер құрылымы сөздік немесе ассоциативті массив деп аталады. Python тіліндегі сәйкес деректер құрылымы dict деп аталады.</p>
    <p>Сөздікті пайдаланудың қарапайым мысалын қарастырайық. «Capitals» сөздігін жасап көрейік, онда индексі елдің аты, мәні осы елдің астанасының атауы. Бұл оның астанасын ел атауы бар сызық бойынша анықтауды жеңілдетеді.</p>
{% endblock %}

{% block text_content2 %}
    <p>Сонымен, әрбір сөздік элементі екі нысаннан тұрады: кілт және мән. Біздің мысалда кілт – елдің аты, элемент – астананың аты. Кілт сөздіктің элементін анықтайды, мән – берілген кілтке сәйкес деректер. Негізгі мәндер бірегей; сөздікте екі бірдей кілт болуы мүмкін емес.</p>
    <p>Сөздіктер өмірде кеңінен қолданылады, мысалы, кәдімгі қағаз сөздіктер (түсіндірме, орфографиялық, лингвистикалық). Оларда кілт – мақаланың сөз-атауы, ал құндылық – мақаланың өзі. Мақалаға қол жеткізу үшін кілт сөзді көрсету керек.</p>
    <p>Деректер құрылымы ретінде сөздіктің тағы бір мысалы - телефон анықтамалығы. Онда кілт - атау, ал мән - телефон нөмірі. Сөздікте, телефон анықтамалығы да белгілі перне арқылы сөздік жазбасын табу оңай болатындай етіп сақталады (мысалы, жазбалар пернелердің алфавиттік ретімен сақталса, белгілі кілтті табу оңай, мысалы, екілік іздеу арқылы), бірақ кілт белгісіз болса және тек мәні белгілі болса, берілген мәні бар элементті іздеу сөздіктің барлық элементтерін дәйекті түрде сканерлеуді қажет етуі мүмкін.</p>
    <p>Ассоциативті массивтің ерекше қасиеті оның динамизмі болып табылады: ерікті кілттермен жаңа элементтерді қосуға және бар элементтерді жоюға болады. Бұл жағдайда пайдаланылатын жадтың өлшемі ассоциативті массив өлшеміне пропорционалды болады. Ассоциативті массивтің элементтеріне қол жеткізу әдеттегі массивтерге қарағанда баяуырақ болса да, әдетте өте жылдам.</p>
    <p>Python тілінде кілт ерікті өзгермейтін деректер түрі болуы мүмкін: бүтін және нақты сандар, жолдар, кортеждер. Сөздіктегі кілт жиын бола алмайды, бірақ ол frozenset түрінің элементі болуы мүмкін: жиын түріне ұқсас арнайы деректер түрі, жасалғаннан кейін өзгерту мүмкін емес. Сөздік элементінің мәні кез келген деректер түрі, соның ішінде өзгермелі болуы мүмкін.</p>
    <h1>Сөздіктерді қашан пайдалану керек</h1>
    <p>Сөздіктерді келесі жағдайларда қолдану керек:</p>
    <p>Кейбір объектілердің санын санау. Бұл жағдайда кілттер объектілер, ал мәндер олардың саны болатын сөздік жасау керек.
    <p>Нысанмен байланысты кез келген деректерді сақтау. Кілттер - бұл объектілер, мәндер - олармен байланысты деректер. Мысалы, оның реттік нөмірін айдың аты бойынша анықтау қажет болса, онда мұны сөздік арқылы жасауға болады Num['January'] = 1; Сан['February'] = 2; ....</p>
    <p>Объектілер арасындағы сәйкестікті орнату (мысалы, «ата-ана-бала»). Кілт - объект, мән - сәйкес объект.</p>
    <p>Егер сізге кәдімгі массив қажет болса, бірақ элементтің максималды индекс мәні өте үлкен болса және барлық мүмкін индекстер пайдаланылмаса («сирек массив» деп аталады), онда жадты сақтау үшін ассоциативті массивді пайдалануға болады.</p>
    <h1>Сөздік құру</h1>
    <p>Бос сөздікті dict() функциясын немесе бос бұйра жақшалар жұбы {} арқылы жасауға болады (сол себепті бос жиынды құру үшін бұйра жақшаларды пайдалану мүмкін емес). Белгілі бір бастапқы мәндер жиыны бар сөздікті жасау үшін келесі конструкцияларды пайдалануға болады:</p>
{% endblock %}

{% block text_content3 %}
    <p>Алғашқы екі әдісті тек олардың барлық элементтерін тізімдей отырып, шағын сөздіктер жасау үшін пайдалануға болады. Сонымен қатар, екінші әдісте пернелер dict функциясына аталған параметрлер ретінде беріледі, сондықтан бұл жағдайда пернелер тек жолдар болуы мүмкін және олар жарамды идентификаторлар болып табылады. Үшінші және төртінші жағдайларда дайын тізімдерді дәлел ретінде тапсырсаңыз, үлкен сөздіктерді жасауға болады, оларды міндетті түрде барлық элементтерді тізімдеу арқылы емес, бағдарламаны орындау кезінде құрастырылған кез келген басқа жолмен алуға болады. Үшінші әдісте dict функциясына тізімді беру қажет, оның әрбір элементі екі элементтен тұратын кортеж: кілт және мән. Төртінші әдіс zip функциясын пайдаланады, оған бірдей ұзындықтағы екі тізім беріледі: пернелер тізімі және мәндер тізімі.</p>
    <p>Сөздік элементтерімен жұмыс</p>
    <p>Негізгі операция: тізімдердегідей жазылған кілт арқылы элемент мәнін алу: A[key]. Егер берілген кілті бар элемент сөздікте болмаса, KeyError ерекше жағдайы көтеріледі.</p>
    <p>Кілт арқылы мәнді анықтаудың тағы бір жолы get методы болып табылады: get: A.get(key). Егер get кілті бар элемент сөздікте болмаса, онда None қайтарылады. Екі аргументті белгілеу пішінінде A.get(key, val) әдісі кілті бар элемент сөздікте болмаса, val мәнін қайтарады.</p>
    <p>Элементтің сөздікке тиесілілігін жиындардағы сияқты операцияларда емес, in арқылы тексеруге болады.</p>
    <p>Сөздікке жаңа элемент қосу үшін оған кейбір мәнді тағайындау жеткілікті: A[key] = value.</p>
    <p>Сөздіктен элементті жою үшін del A[key] операциясын пайдалануға болады (операция сөздікте ондай кілт жоқ болса, KeyError ерекше жағдайын тудырады. Мұнда сөздіктен элементті жоюдың екі қауіпсіз жолы берілген.</p>
{% endblock %}

{% block text_content4 %}
    <p>Бірінші жағдайда біз алдымен элементтің бар-жоғын тексереміз, ал екіншісінде біз ерекше жағдайды ұстаймыз және өңдейміз.</p>
    <p>Сөздіктен элементті жоюдың тағы бір жолы pop әдісін қолдану болып табылады: A.pop(key). Бұл әдіс жойылатын элементтің мәнін қайтарады, егер осы кілті бар элемент сөздікте болмаса, ерекше жағдай көтеріледі. Екінші параметрді pop әдісіне өткізсеңіз, онда элемент сөздікте болмаса, pop әдісі осы параметрдің мәнін қайтарады. Бұл сөздіктен элементті қауіпсіз жоюдың ең оңай жолына мүмкіндік береді: A.pop(key, None).</p>
    <p>Сөздік элементтерін асып кетуі</p>
    <p>Сөздіктегі барлық элементтердің кілттерінің тізімін оңай ұйымдастыруға болады:</p>
{% endblock %}

{% block text_content5 %}
    <p>Келесі методтар сөздік элементтерінің көріністерін қайтарады. Көріністер жиындарға ұқсайды, бірақ сөздік элементтерінің мәндері өзгерсе, олар өзгереді. keys методы барлық элементтердің кілттерінің көрінісін қайтарады, values әдісі барлық мәндердің көрінісін қайтарады және items әдісі кілттер мен мәндердің барлық жұптарының (кортеждерінің) көрінісін қайтарады.</p>
    <p>Тиісінше, сіз А сөздігі элементтерінің барлық мәндерінің арасында val мәні бар-жоғын келесідей жылдам тексеруге болады: val in A.values() және key айнымалысы элементтің кілтін қамтитындай циклды ұйымдастырыңыз. , ал val айнымалысы оның мәнін қамтиды:</p>
{% endblock %}

{% block trinket_url1 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk8mvxx?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true" width="100%"></iframe>
{% endblock %}

{% block trinket_url2 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk8s886?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true" width="100%"></iframe>
{% endblock %}

{% block trinket_url3 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk8urdn?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true" width="100%"></iframe>
{% endblock %}

{% block trinket_url4 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk8wgh6?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true" width="100%"></iframe>
{% endblock %}

{% block trinket_url5 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk8xx59?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true" width="100%"></iframe>
{% endblock %}
