{% extends 'lecture/lecture.html' %}

{% block title %}
    While циклі
{% endblock %}

{% block header %}
    <h1>While циклі</h1>
{% endblock %}

{% block lecture_nav_6 %}
    <a href="#h1"><li>1. While циклі</li></a>
    <a href="#h2"><li>2. Циклды басқару инструкциялары</li></a>
    <a href="#h3"><li>3. Мәндерді параллель алмастыру</li></a>
{% endblock %}

{% block text_content1 %}
    <h1 id="h1">1. While циклі</h1>
    <p><code>while</code> циклі тексерілетін шарт ақиқат болғанша бірдей әрекеттер тізбегін қайталап орындауға мүмкіндік береді. Шарт цикл денесінің алдында жазылады және цикл денесі орындалмас бұрын тексеріледі. Әдетте, уақытша цикл немесе циклдің орындалу санын нақты анықтау мүмкін болмаған кезде қолданылады.</p>
    <p><code>while</code> циклінің синтаксисі ең қарапайым жағдайда келесідей:</p>
    <pre class="code">
while шарт:
       инструкция блогы
    </pre>
    <p><code>while</code> циклін орындау кезінде алдымен шарт тексеріледі. Егер ол жалған болса, онда циклдің орындалуы тоқтатылады және басқару <code>while</code> циклінің денесінен кейінгі келесі командаға ауысады. Егер шарт ақиқат болса, онда оператор орындалады, содан кейін шарт қайтадан тексеріліп, оператор қайтадан орындалады. Бұл шарт дұрыс болғанша жалғасады. Шарт жалған болғаннан кейін цикл аяқталады және басқару циклден кейінгі келесі нұсқауға ауысады.</p>
    <p>Мысалы, келесі бағдарлама фрагменті 1-ден 10-ға дейінгі барлық бүтін сандардың квадраттарын басып шығарады. Сіз төменде көрсетілген мысалдан <code>while</code> циклінің <code>for … in range( … )</code> орнын алмастыра алатынын көре аласыз:</p>
{% endblock %}

{% block text_content2 %}
    <p>Бұл мысалда цикл ішіндегі <code>i</code> айнымалысы 1-ден 10-ға дейін өзгереді. Циклдің әрбір жаңа өтуімен мәні өзгеретін мұндай айнымалы санауыш(счетчик) деп аталады. Осы фрагментті орындағаннан кейін <code>i</code> айнымалысының мәні <code>11</code>-ге тең болатынын ескеріңіз, өйткені <code>i == 11</code> кезінде <code>i <= 10</code> шарты енді бірінші рет орындалмайтын болады.</p>
    <p>Міне, <code>n</code> натурал санының цифрларының санын анықтау үшін <code>while</code> циклін пайдаланудың тағы бір мысалы:</p>
{% endblock %}

{% block text_content3 %}
    <p>Бұл циклде <code>length</code> айнымалысында мұның неше рет орындалғанын есептей отырып, сандардың соңынан бастап бір таңбалы сандарды алып тастаймыз, бұл бүтін санды 10-ға бөлуге тең (<code>n //= 10</code>).</p>
    <p>Python-да бұл мәселені шешудің тағы бір жолы: <code>length = len(str(n))</code>.</p>
{% endblock %}

{% block text_content4 %}
    <h1 id="h2">2. Циклды басқару инструкциялары</h1>
    <p>Цикл денесінен кейін <code>else</code> сөзін жазуға болады: одан кейін тексерілетін шарт жалған болған кезде цикл аяқталғаннан кейін бір рет орындалатын операциялар блогы:</p>
{% endblock %}

{% block text_content5 %}
    <p>Мұның мағынасы жоқ сияқты, өйткені дәл сол нұсқаулықты цикл аяқталғаннан кейін ғана жазуға болады. Мағынасы <code>break</code> инструкциясымен ғана бар болады. Орындау кезінде, егер Python цикл ішінде <code>break</code> инструкциясына тап болса, ол циклды орындауды дереу тоқтатады және одан шығады. Бұл жағдайда <code>else</code> тармағы орындалмайды. Әрине, break инструкциясы <code>if</code> операторының ішінде ғана шақырылуы керек, яғни ол қандай да бір ерекше шарт орындалған жағдайда ғана орындалуы керек.</p>
    <p>Теріс санға тап болғанша сандарды оқитын бағдарламаның мысалы келтірілген. Теріс сан пайда болғанда, бағдарлама аяқталады. Бірінші нұсқада сандар тізбегі 0 санымен аяқталады (оны оқу кезінде тоқтату керек).</p>
{% endblock %}

{% block text_content6 %}
    <p>Бағдарламаның екінші нұсқасында алдымен кіріске реттілік элементтерінің саны, содан кейін элементтердің өздері беріледі. Бұл жағдайда <code>for</code> циклін пайдалану ыңғайлы. <code>for</code> циклінде <code>else</code> те болуы мүмкін және оның ішінде <code>break</code> функциясы да болуы мүмкін.</p>
{% endblock %}

{% block text_content7 %}
    <p>Тағы бір циклды басқару инструкциясы – <code>continue(циклдің жалғасуы)</code>. Егер бұл инструкция циклдің ортасында бір жерде кездессе, онда циклдың соңына дейін қалған барлық нұсқаулар өткізіп жіберіледі және циклдің орындалуы келесі итерациямен жалғасады.</p>
    <p>Егер <code>break</code> және <code>continue</code> инструкциялары бірнеше кірістірілген циклдар ішінде болса, олар тек ішкі циклдің орындалуына әсер етеді. Міне, мұны көрсететін мысал:</p>
{% endblock %}

{% block text_content8 %}
    <p>Мұнда <code>break</code> инструкциясын дұрыс пайдаланудың әдеттегі мысалы келтірілген (бұл код сандағы таңбалар санын есептейді).</p>
{% endblock %}

{% block text_content9 %}
    <p>Бұл циклды келесідей қайта жазу әлдеқайда жақсы:</p>
{% endblock %}

{% block text_content10 %}
    <p>Дегенмен, Python-да неғұрлым талғампаз шешім ұсынылуы мүмкін:</p>
{% endblock %}

{% block text_content11 %}
    <h1 id="h3">3. Мәндерді параллель алмастыру</h1>
    <p>Python-да бір меншіктеу инструкциясында бірнеше айнымалылардың мәнін бірден өзгертуге болады. Бұл келесідей орындалады:</p>
    <code>a, b = 0, 1</code>
    <p>Бұл кодты келесідей жазуға болады:</p>
    <code>a = 0<br>b = 1</code>
    <p>Екі әдістің айырмашылығы бірінші әдісте бірнеше тағайындау бір уақытта екі айнымалының мәнін өзгертеді.</p>
    <p>Егер бірнеше тапсырмадағы «=» белгісінің сол жағында үтірмен бөлінген айнымалы атаулар болуы керек болса, оң жағында үтірмен бөлінген ерікті өрнектер болуы мүмкін. Ең бастысы, тапсырма белгісінің сол және оң жағында бірдей элементтер саны бар.</p>
    <p>Бірнеше тағайындау екі айнымалының мәндерін алмасу қажет болғанда пайдалы. Кәдімгі бағдарламалау тілдерінде арнайы функцияларды қолданбай, бұл келесідей орындалады:</p>
{% endblock %}

{% block text_content12 %}
    <p>Python-да бірдей әрекет бір жолда жазылады:</p>
{% endblock %}

{% block trinket_url1 %}
    <iframe src="https://trinket.io/embed/python/bdaeb8d154" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url2 %}
    <iframe src="https://trinket.io/embed/python/2396688df8" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url4 %}
    <iframe src="https://trinket.io/embed/python/9b1d7b2c0e" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url5 %}
    <iframe src="https://trinket.io/embed/python/f7e75d03e5" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url6 %}
    <iframe src="https://trinket.io/embed/python/8c1dc66116" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url7 %}
    <iframe src="https://trinket.io/embed/python/a2651096d9" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url8 %}
    <iframe src="https://trinket.io/embed/python/6c01a77b3b" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url9 %}
    <iframe src="https://trinket.io/embed/python/a78d3de5da" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url10 %}
    <iframe src="https://trinket.io/embed/python/320f21bbb9" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url11 %}
    <iframe src="https://trinket.io/embed/python/7c0a37c149" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}

{% block trinket_url12 %}
    <iframe src="https://trinket.io/embed/python/7c1848bd8b" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
{% endblock %}
