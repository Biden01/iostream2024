{% extends 'lecture/lecture.html' %}

{% block title %}
    Функциялар және рекурсия
{% endblock %}

{% block header %}
    <h1>Функциялар және рекурсия</h1>
{% endblock %}

{% block lecture_nav_8 %}
    <a href="#h1"><li>1. Функциялар</li></a>
    <a href="#h2"><li>2. Локальді және глобальды айнымалылар</li></a>
    <a href="#h3"><li>3. Рекурсия</li></a>
{% endblock %}

{% block text_content1 %}
    <h1 id="h1">1. Функциялар</h1>
    <p>Еске салайық, математикада n санының факториалы n! ретінде анықталады: n! = 1 ⋅ 2 ⋅ ... ⋅ n. Мысалы, 5! = 1 ⋅ 2 ⋅ 3 ⋅ 4 ⋅ 5 = 120. Факториалды for циклі арқылы оңай есептеуге болатыны анық. Біздің бағдарламамызда (немесе кодтың әртүрлі орындарында) әртүрлі сандардың факториалын бірнеше рет есептеу керек деп елестетіп көрейік. Әрине, факторлық есептеуді бір рет жазуға болады, содан кейін оны қажетті жерге қою үшін Көшіру-Қою пернесін қолдануға болады.</p>
{% endblock %}

{% block text_content2 %}
    <p>Алайда, егер бастапқы кодта бір рет қателессек, онда бұл қате кодта факториалды есептеуді көшірген барлық жерлерде пайда болады. Сонымен қоса, код мүмкін болатыннан көбірек орын алады. Бір логиканы қайта-қайта жазбау үшін бағдарламалау тілдерінің функциялары бар.</p>
    <p>Функциялар программаның қалған бөлігінен оқшауланған және олар шақырылған кезде ғана орындалатын код бөлімдері. Сіз sqrt(), len() және print() функцияларын көрдіңіз. Олардың барлығының ортақ қасиеті бар: олар параметрлерді қабылдай алады (нөл, бір немесе одан да көп) және мәнді қайтара алады (бірақ олар болмауы мүмкін). Мысалы, sqrt() функциясы бір параметрді алып, мәнді (санның түбірі) қайтарады. print() функциясы параметрлердің айнымалы санын қабылдайды және ештеңені қайтармайды.</p>
    <p>Бір параметрді - санды қабылдайтын және осы санның факториалы мәнін қайтаратын factorial() функциясын жазу жолын көрсетейік.</p>
{% endblock %}

{% block text_content3 %}
    <p>Бірнеше түсініктеме берейік. Біріншіден, функция коды бағдарламаның басында, дәлірек айтсақ, factorial() функциясын қолданғымыз келетін жердің алдында орналасуы керек. Бұл мысалдың бірінші жолы функциямыздың сипаттамасы болып табылады. factorial()– идентификатор, яғни функциямыздың атауы. Жақшадағы идентификатордан кейін біздің функция қабылдайтын параметрлер тізімі бар. Тізім үтірмен бөлінген параметр идентификаторларынан тұрады. Біздің жағдайда тізім бір n мәнінен тұрады. Жолдың соңына қос нүкте қойылады.</p>
    <p>Одан кейін блок ретінде құрастырылған функцияның денесі келеді, яғни шегініс(табуляция). Функцияның ішінде n факторлық мәні есептеледі және res айнымалысында сақталады. Функцияны тоқтататын және res айнымалысының мәнін қайтаратын return res операторымен аяқталады.</p>
    <p>Қайтару нұсқауы функцияның кез келген жерінде пайда болуы мүмкін, оның орындалуы функцияны тоқтатады және көрсетілген мәнді шақырылған жерге қайтарады. Егер функция мәнді қайтармаса, онда қайтару операторы қайтару мәнінсіз пайдаланылады. Мәнді қайтаруды қажет етпейтін функцияларда қайтару мәлімдемесі болмауы мүмкін – оларды процедура деп те атайды.</p>
    <p>Тағы бір мысал келтірейік. Екі санды қабылдайтын және олардың максимумын қайтаратын max() функциясын жазайық (шын мәнінде мұндай функция Python-да бар).</p>
{% endblock %}

{% block text_content4 %}
    <p>Енді үш санды қабылдайтын және олардың максимумын қайтаратын max3() функциясын жаза аламыз.</p>
{% endblock %}

{% block text_content5 %}
    <p>Біздің құрастырған функцияларымыз 2-3 ұана сан қабылдай алады, демек әлсізб нашар функция болып тұр. Ал Python-ның өзінің негізгі max() функциясы аргументтердің бірнеше санын қабылдап, олардың максимумын қайтара алады. Мұндай функцияны қалай жазуға болатынына мысал келтірейік.</p>
{% endblock %}

{% block text_content6 %}
    <p>Осы функцияға жіберілген барлық параметрлер функцияны жариялау жолындағы жұлдызшамен көрсетілгендей a деп аталатын бір кортежге жиналады.</p>
{% endblock %}

{% block text_content7 %}
    <h1 id="h2">2. Локальді және глобальды айнымалылар</h1>
    <p>Функцияның сыртында жарияланған айнымалы мәндерін функцияның ішіндегі пайдалануға болады.</p>
{% endblock %}

{% block text_content8 %}
    <p>Мұнда <code>a</code> айнымалысына 1 мәні тағайындалады және <code>f()</code> функциясы бұл мәнді басып шығарады, тіпті бұл айнымалы <code>f</code> функциясы жарияланғанға дейін инициализацияланбаған. <code>f()</code> шақырылғанда, <code>a</code> мәні әлдеқашан тағайындалған, сондықтан <code>f()</code> оны экранда көрсете алады.</p>
    <p>Мұндай айнымалылар (функцияның сыртында жарияланған, бірақ функцияның ішінде қолжетімді) глобальды деп аталады.</p>
    <p>Бірақ функцияның ішінде айнымалы мәнді инициализацияласаңыз, бұл айнымалы мәнді функциядан тыс пайдалана алмайсыз. Мысалы:</p>
{% endblock %}

{% block text_content9 %}
    <p>Біз <code>NameError: name 'a' is not defined</code> қатесін аламыз: <code>'a'</code> атауы анықталмаған. Функция ішінде жарияланған мұндай айнымалылар локалдьді деп аталады. Бұл айнымалылар функция шыққаннан кейін қолжетімсіз болады.</p>
    <p>Функция ішіндегі глобальды айнымалының мәнін өзгертуге тырыссаңыз, нәтиже қызықты болады:</p>
{% endblock %}

{% block text_content10 %}
    <p>1 және 0 сандары басып шығарылады, <code>а</code> айнымалысының мәні функцияның ішінде өзгерсе де, функцияның сыртында ол өзгеріссіз қалады! Бұл функцияның кездейсоқ өзгерістерінен жаһандық айнымалыларды «қорғау» үшін жасалады. Мысалы, егер функция циклден <code>i</code> айнымалысы арқылы шақырылса және бұл функция циклды ұйымдастыру үшін <code>i</code> айнымалысын да пайдаланса, онда бұл айнымалылар әртүрлі болуы керек. Соңғы сөйлемді түсінбесеңіз, келесі кодты қарап шығыңыз және функцияның ішінде <code>i</code> айнымалысы өзгертілсе, оның қалай жұмыс істейтіні туралы ойланыңыз.</p>
{% endblock %}

{% block text_content11 %}
    <p>Егер глобальды айнымалы i функцияның ішінде өзгертілсе, біз мынаны аламыз:</p>
    <pre>
    5! = 1
    5! = 2
    5! = 6
    5! = 24
    5! = 120
    </pre>
    <p>Сонымен, егер қандай да бір айнымалының мәні функцияның ішінде өзгертілсе, онда бұл атаудағы айнымалы локальді айнымалыға айналады және оның модификациясы бірдей атпен глобальды айнымалыны өзгертпейді.</p>
    <p>Ресми түрде: Python интерпретаторы берілген функция үшін жергілікті айнымалыны қарастырады, егер оның кодында айнымалының мәнін өзгертетін кем дегенде бір нұсқау болса, онда бұл айнымалы локальді болып саналады және оны инициализациялау алдында пайдалану мүмкін емес; Айнымалының мәнін өзгертетін нұсқаулар <code>=</code>, <code>+=</code> операторлары, сонымен қатар айнымалыны <code>for</code> циклінің параметрі ретінде пайдалану болып табылады. Сонымен қатар, айнымалыны өзгертетін нұсқау ешқашан орындалмаса да, интерпретатор мұны тексере алмайды және айнымалы әлі де жергілікті болып саналады. Мысалы:</p>
{% endblock %}

{% block text_content12 %}
    <p>Қате орын алды: <code>UnboundLocalError: local variable 'a' referenced before assignment</code>. Атап айтқанда, <code>f()</code> функциясында <code>a</code> идентификаторы локальді айнымалыға айналады, өйткені функцияда, тіпті ол ешқашан орындалмаса да айнымалыны өзгертетін пәрмен бар (бірақ интерпретатор мұны бақылай алмайды). Сондықтан <code>a</code> айнымалысын басып шығару инициализацияланбаған локальді айнымалыға қол жеткізуге әкеледі.</p>
    <p>Функцияның глобальды айнымалының мәнін өзгертуі үшін, бұл айнымалыны функцияның ішіндегі <code>global</code> кілт сөзін пайдаланып, глобальды деп жариялау қажет:</p>
{% endblock %}

{% block text_content13 %}
    <p>Бұл мысалда экранда 1 1 көрсетіледі, өйткені <code>a</code> айнымалысы глобальды деп жарияланған және оны функцияның ішінде өзгерту айнымалының функциядан тыс қолжетімді болуына әкеледі.</p>
    <p>Дегенмен, функция ішіндегі глобальды айнымалылардың мәндерін өзгертпеген дұрыс. Функцияңыз кейбір айнымалы мәнді өзгертуі керек болса, ол осы мәнді қайтарса жақсы болар еді және сіз функцияны шақырған кезде бұл мәнді айнымалыға нақты тағайындайсыз. Егер сіз осы ережелерді орындасаңыз, онда функциялар кодқа тәуелсіз және оларды бір бағдарламадан екіншісіне оңай көшіруге болады.</p>
    <p>Мысалы, сіздің бағдарламаңыз f айнымалысында сақтағыңыз келетін кіріс санының факториалын есептеуі керек делік. Міне, мұны істемеу жолы:</p>
{% endblock %}

{% block text_content14 %}
    <p>Бұл код нашар жазылған, себебі оны қайта пайдалану қиын. Ертең факторлық функцияны басқа бағдарламада пайдалану қажет болса, бұл функцияны осы жерден көшіріп алып, оны жаңа бағдарламаңызға қоюға болмайды. Есептелген мәнді қайтару жолын өзгертуге тура келеді.</p>
    <p>Бұл мысалды келесідей қайта жазу әлдеқайда жақсы:</p>
{% endblock %}

{% block text_content15 %}
    <p>Егер сізге бір мәнді емес, екі немесе одан да көп мәнді қайтаратын функция қажет болса, онда бұл мақсат үшін функция екі немесе одан да көп мәндердің тізімін қайтара алады:</p>
        <code>return [a, b]</code>
    <p>Содан кейін функция шақыруының нәтижесі бірнеше тағайындауда қолданылуы мүмкін:</p>
        <code>n, m = f(a, b)</code>
{% endblock %}

{% block text_content16 %}
    <h1 id="h3">3. Рекурсия</h1>
{% endblock %}

{% block text_content17 %}
    <p>Жоғарыда көргеніміздей, функция басқа функцияны шақыра алады. Бірақ функция өзін шақыра алады! Мұны мысал ретінде факториал есептеу функциясын қолданып қарастырайық. 0!=1, 1!=1 болатыны белгілі. n мәнін қалай есептеу керек! үлкен n үшін? Егер біз (n-1)! мәнін есептей алатын болсақ, онда n!-ді оңай есептей аламыз, өйткені n!=n⋅(n-1)!. Бірақ қалай есептеу керек (n-1)!? (n-2)! есептесек, онда (n-1)!=(n-1)⋅(n-2)! де есептей аламыз!. (n-2) қалай есептеу керек!? Тек... Ақырында біз 1-ге тең 0! мәніне жетеміз. Сонымен факториалды есептеу үшін кішірек сан үшін факториал мәнін қолдануға болады. Мұны Python бағдарламасында да жасауға болады:</p>
{% endblock %}

{% block text_content18 %}
    <p>Бұл әдіс (өзін шақыратын функция) рекурсия, ал функцияның өзі рекурсивті деп аталады.</p>
    <p>Рекурсивті функциялар программалаудағы қуатты механизм болып табылады. Өкінішке орай, олар әрқашан тиімді бола бермейді. Сондай-ақ, рекурсияны пайдалану жиі қателіктерге әкеледі. Бұл қателердің ең жиі кездесетіні шексіз рекурсия болып табылады, функционалдық шақырулар тізбегі ешқашан аяқталмайды және компьютердегі бос жад таусылғанша жалғасады. Шексіз рекурсияның мысалы осы бөлімнің эпиграфында келтірілген. Шексіз рекурсияның ең көп тараған екі себебі:</p>
    <ol style="margin-left: 40px">
        <li>Рекурсиядан қате шығу. Мысалы, егер факторлық есептеу бағдарламасында <code>if n == 0</code> екенін тексеруді ұмытсақ, онда <code>factorial(0)</code> <code>factorial(-1)</code> шақырады, ол <code>factorial(-2)</code> және т.б.</li>
        <li>Жарамсыз параметрлері бар рекурсивті шақыру. Мысалы, <code>factorial(n)</code> функциясы <code>factorial(n)</code> шақырса, онда нәтиже де шексіз тізбек болады.</li>
    </ol>
    <p>Сондықтан рекурсивті функцияны жасағанда, ең алдымен рекурсияның аяқталу шарттарын рәсімдеу керек және рекурсия неліктен бір кездері тоқтатылатыны туралы ойлану керек.</p>
{% endblock %}

{% block trinket_url1 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvmvr9?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url2 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvs64n?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url3 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvt9vt?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url4 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvtxjs?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url5 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvumg8?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url7 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvvbhh?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url8 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk7cpfq?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url9 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hk79df7?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url10 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvxrz4?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url11 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvyb4d?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url12 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvyxpy?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url13 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjvzkt4?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url16 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjw2kns?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url17 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjw2kns?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}

{% block trinket_url18 %}
    <iframe height="450px" src="https://onecompiler.com/embed/python/42hjw5e9z?hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=false" width="100%"></iframe>
{% endblock %}
